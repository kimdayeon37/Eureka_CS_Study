
# 2. TCP와 UDP
## 2.1 TCP 🍀🍀🍀
- 전송계층에 해당하는 네트워크 프로토콜
- **연결형 서비스를 지원**하고 데이터의 신뢰성을 보장한다
- 패킷 교환 방식은 패킷이 전달되는 회선이 정해져 있는 가상회선 방식이다
- 패킷의 전송 순서가 보장된다
- 패킷의 수신 여부를 확인한다
- 송신부와 수신부는 1:1 통신을 한다
- 데이터 손실이 없음을 보장하므로 신뢰성이 높다
- 데이터의 송수신 속도가 느리다

### 패킷 교환 방식
- `가상 회선 방식` 데이터를 주고받기 전에 패킷을 전송할 경로인 가상회선을 설정해서 모든 패킷을 같은 경로로 전송한다
- `데이터그램 방식` 패킷마다 최적의 경로로 전송되는 방식으로, 송신부에서 보낸 패킷 순서와 수신부에 도착하는 패킷의 순서가 다를 수 있다

## 2.2 TCP Handshaking
- TCP는 연결형 서비스를 지원하기 위해 송신부와 수신부를 연결하는 과정을 거친다
- 연결을 시작할 때에는 3-way handshaking, 연결을 종료할 때에는 4-way handshaking을 진행한다
- 연결을 제어하고 관리하기 위한 플래그
	- `SYN` (Synchronization) 연결을 생성할 때 사용
    - `FIN` (Finish) 연결을 종료할 때 사용
    - `ACK` (Acknowledgement) 데이터를 전송하면 수신자가 받았음을 알릴 때 사용
    - `RST` (Reset) 연결을 재설정할 때 사용
    - `RSH` (Push) 빠른 응답이 필요한 데이터를 응용 계층으로 즉시 전송할 때 사용
    - `URG` (Urgent) 다른 데이터보다 우선순위 높은 데이터를 전송할 때 사용
    
### 3-way handshaking
- 상대방 컴퓨터와 세션을 수립하는 과정
![](https://media.geeksforgeeks.org/wp-content/uploads/TCP-connection-1.png)
1. 클라이언트가 서버에게 SYN 패킷을 보냄 (sequence = x)
2. 서버가 SYN(x)를 받고, 클라이언트로 ACK과 SYN 패킷을 보냄 (sequence = y, ACK = x + 1)
3. 클라이언트는 ACK(x+1)과 SYN(y) 패킷을 받고, ACK(y+1)을 보냄

→ 이렇게 3번의 통신이 완료되면 연결이 성립된다

### 4-way handshaking
- TCP 연결을 해제할 때 이루어지는 과정
![](https://media.geeksforgeeks.org/wp-content/uploads/CN.png) 
1. 클라이언트는 서버에게 연결을 종료한다는 FIN 플래그를 보낸다
2. 서버는 FIN을 받고, ACK을 클라이언트에게 보낸다 (이때 모든 데이터를 보내기 위해 CLOSE_WAIT 상태가 된다)
3. 데이터를 모두 보냈다면 연결이 종료되었다는 FIN 플래그를 클라이언트에게 보낸다
4. 클라이언트는 FIN을 받고 ACK을 서버에게 보낸다 (아직 서버로부터 받지 못한 데이터가 있을 수 있으므로 TIME_WAIT을 통해 기다린다)
- 서버는 ACK를 받은 이후 소켓을 닫는다 (Closed)
- TIME_WAIT 시간이 지나면 클라이언트도 닫는다 (Closed)

## 2.3 TCP 제어 방법 🍀
TCP의 데이터 신뢰성을 보장하기 위한 제어 방법으로, 흐름제어, 혼잡제어, 오류제어가 있다

### 흐름 제어 (Flow control)
- 데이터 송신부와 수신부에서 데이터 처리 속도의 차이 때문에 생기는 데이터 손실을 방지하는 방법
- `정지-대기 (stop-wait)`
	- 송신부에서 데이터를 보낸 후 수신부로부터 ACK 메시지를 받을 때까지 다음 데이터를 보내지 않고 기다리는 방식
    - 송신부에서 패킷을 보내고 일정 시간 동안 수신부로부터 ACK을 받지 못하면 패킷을 재전송한다
    - `장` 간단하다 `단` 이전 메시지에 대한 응답을 받아야만 다음 메시지를 전송할 수 있어 시간상 비효율적
    
### 슬라이딩 윈도우 (Sliding window)
- 송신부에서 데이터 수신 여부(ACK)를 확인하지 않고 수신부에서 설정한 윈도우 크기만큼 데이터를 연속적으로 보낼 수 있게 해서 데이터 흐름을 동적으로 제어하는 방식
- `윈도우` 크기는 응답받지 않고도 보낼 수 있는 데이터의 최대 개수이고, 3-way handshaking 과정에서 결정된다
![](https://velog.velcdn.com/images/corinthionia/post/00fea398-40cf-45d2-bbf4-f191da313a99/image.png)

### 혼잡 제어 (Congestion control)
- 송신부의 데이터 전달 속도와 네트워크 속도 차이로 데이터 손실이 발생하는 것을 방지하기 위한 방법
- AIMD (Additive Increase Multiplicative Decrease)
	- 데이터를 전달할 때 합 증가 방식으로 혼잡 윈도우의 크기를 더해 가면서 키운다
    - 데이터 손실이 발생하면 혼잡 윈도우의 크기를 곱 감소 방식을 적용해 1/2배와 같이 배수 단위로 줄인다
    - `장` 시간이 지나면 여러 송신부 간에 네트워크 대역폭을 공평하게 사용할 수 있다
    - `단` 데이터 유실이 발생하면 윈도우 크기 증가폭 대비 윈도우 크기 감소폭이 크기 때문에, 네트워크 대역폭을 넓게 사용하기 전까지 오랜 시간이 걸린다
- Slow start (느린 시작)
	- 윈도우 크기가 1인 상태에서 시작해 ACK 메시지를 수신할 때마다 윈도우 크기를 1씩 늘려 나간다. 그러다 혼잡이 발생하면 윈도우 크기를 1로 줄인다.
- Congestion avoidance (혼잡 회피)
	- 윈도우 크기가 지수 함수 형태로 증가하다가 혼잡이 발생하는 것을 방지하기 위해 윈도우 크기에 대한 임계점(threshold)을 정하는 바익
    - 윈도우 크기가 임계점에 도달하면 윈도우 크기를 선형적으로 증가하게 된다
- Fast recovery (빠른 회복)
	- 혼잡이 발생하면 윈도우 크기를 절반으로 줄인 후 선형적으로 증가하는 방식
    - 혼잡이 처음 발생하면 AIMD 방식으로 동작한다
- Fast retransmit (빠른 재전송)
	- Duplicate ACK가 3번 발생하면 해당 시점의 윈도우 크기를 1/2로 줄인다. 그 후 ACK을 받으면 다시 윈도우 크기를 키운다.
    - Duplicate ACK란, 패킷이 순서대로 도착하지 않아서 받아야 할 차례의 패킷을 ACK 메시지와 함께 요청하는 것을 뜻한다


### 오류 제어 (Error control)
- 데이터에 오류 또는 유실이 발생할 때, 데이터의 신뢰성을 보장하기 위해 오류를 제어하는 방식
- 데이터의 오류 또는 유실 발생을 인지하는 경우
	- 수신부에서 잘못된 데이터를 받았다는 응답인 NAK(Negative Acknowledge) 메시지를 보낸 경우
    - 3 Duplicate ACK가 발생한 경우
    - 수신부로부터 ACK 메시지를 받지 못해 타임아웃이 발생할 경우
- Stop-wait (정지-대기)
	- 송신한 패킷에 대한 ACK 메시지를 일정 시간 동안 받지 못해 타임아웃이 발생하면 해당 패킷을 다시 보내는 방식
    - 데이터 유실을 간단히 처리할 수 있어 흐름제어와 오류제어에 사용된다
	- 송신부에서 데이터를 1개만 보내고 메시지를 기다려야 하기 때문에 ARQ 방식이 사용된다
- Go-Back-N ARQ
	- 송신부에서 연속적으로 데이터를 보냈을 때 누락된 데이터가 있으면 송신부에서 해당 데이터부터 재전송하는 방식
- Selective-Repeat ARQ
	- 송신부에서 연속적으로 데이터를 보냈을 때 누락된 데이터가 있다면 수신부에서 해당 데이터만 재전송을 요청하는 방식

## UDP 🍀🍀🍀
- TCP와 마찬가지로 전송 계층에 해당하는 네트워크 프로토콜
- 송신부와 수신부의 연결이 보장되지 않는 비연결형 서비스
- 패킷이 서로 다른 회선으로 교환될 수 있는 데이터그램 패킷 교환 방식
- 송신부와 수신부 간 연결을 지원하지 않고 데이터그램 형태의 통신을 지원
- 송신부에서 전달한 패킷 순서와 수신부에서 받은 패킷 순서가 다를 수 있다
- 패킷의 수신 여부를 확인하지 않는다
- 1:1 통신, 1:N 통신, N:N 통신 모두 가능하다
- 3-way handshaking 과정이 필요 없어 패킷을 바로 송수신할 수 있다
- 신뢰성이 낮지만 속도가 빠르다

