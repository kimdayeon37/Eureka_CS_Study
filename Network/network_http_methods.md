# HTTP 메서드

| GET | Read | 데이터 조회 |
| --- | --- | --- |
| POST | Create | 메시지 바디에 있는 데이터를 추가할 때 사용 |
| PUT | Update | 특정 데이터 수정 요청  |
| DELETE | Delete | 데이터 삭제 |
| PATCH | Update | 데이터를 일부 갱신 |
| HEAD | Read | GET과 동일하게 데이터를 조회할 때 사용하지만, HTTP 메시지에 바디를 포함하지 않고 헤더로만 응답 |

## HTTP 메서드의 속성

- 안전성 (Safe Methods)
- 멱등성 (Idempotent Methods)
- 캐시가능성 (Cacheable Methods)

![Untitled](https://github.com/user-attachments/assets/3963771a-3230-4095-8045-5a782fc37b9e)


### 안전성

HTTP 메소드의 **안전성**이란 보안 취약성을 말하는 것이 아닌 호출해도 리소스가 변경되지 않는 성질로 데이터의 일관성 유지에 있어 안전하다는 의미이다. 전체적인 시스템 장애로부터의 안전성을 의미하진 않는다.

- GET / HEAD는 단순히 데이터를 조회하는 기능을 수행하여 리소스를 변경 및 수정하지 않기 때문에 안전한 HTTP 메소드이다.
- 반면에 POST / PUT / PATCH / DELETE와 같은 메서드들은 호출 시 데이터 변경이 발생하거나, 서버에서 삭제되기 때문에 안전하지 않은 HTTP 메서드인 것이다.

---

### **멱등성(Idempotent)**

멱등이라는 단어는 수학이나 전산학에서 연산을 여러번 적용하더라도 결과가 달라지지 않는 성질을 의미한다.

> *f*(*f*(*f*(*x*)))=*f*(*x*)
> 

이를 HTTP의 멱등성에 대입하면, 요청을 한 번 호출하든 여러번 호출하든 그 결과가 같음을 의미한다.

즉, 동일한 요청을 한번 보내는 것과 연속으로 여러번 보내는 것이 같은 효과를 가지고, 서버 상태에도 동일하게 남을 때 HTTP 메서드가 멱등성을 가진다고 말한다.

또한 호출을 실행한 결과가 의미하는 것이 응답 상태 코드가 아닌 서버의 상태라는 점도 유의해야 한다. 

ex) 똑같은 요청 시 응답 상태 코드가 다르고, 서버의 상태가 같은 상태라면 멱등성 ⭕️

<aside>
💡 멱등의 개념과 안전의 개념을 혼동하기 쉬운데, 차이점을 정확히 알고있자!
1. 안전은 한 번 호출하든 여러번 호출하든 리소스에 수정이 발생하지 않는 속성
2. 멱등은 리소스에 수정이 발생한다하더라도 메서드를 여러번 실행한 결과가 한 번 실행한 결과와 같은 조건을 만족하는 속성

</aside>

### GET의 멱등 ⭕️

GET은 데이터를 한 번 조회하든 여러 번 조회하든 같은 결과가 조회되므로 안전과 멱등을 동시에 만족한다.

```
-- 게시글 조회 (멱등적인 설계 ⭕️)
1. GET /post/1 요청
2. 서버에서 id 1인 게시글 조회
3. 해당 게시글 데이터 응답

--> 요청을 여러번 보내도 서버의 상태는 항상 같게 유지
```

```
-- 조회수 기능 추가, 게시글 조회 (멱등적이지 않은 설계 ❌)
1. GET /post/1 요청
2. 서버에서 id 1인 게시글 조회
3. 해당 게시글 조회수 데이터 1 증가
4. 해당 게시글 데이터 응답

--> GET 요청을 여러번 보낼 시 서버의 데이터가 매번 바뀔 것이다. 
즉, GET의 요청 로직은 멱등성을 가지지 않는 것이며, **HTTP 스펙에 부합하지 않게 API를 구현한 것

따라서 GET의 멱등성에 맞게 API를 설계하기 위해서는, 조회수 컬럼의 값을 증가시키는 요청을 PATCH 요청으로 따로 분리하는 것이 올바르다.**
```

```
A 가 멱등성이 있는 GET 메서드를 사용하였는데도 불구하고, 중간에 B의 개입으로 인해 응답받는 결과값이 달라지게 된다.그럼 멱등성이 깨진 잘못된 설계가 아니냐 라고 반문 할 수 있겠지만, 멱등성의 여부는 외부 요인으로 인해 중간에 리소스가 변경되는 것은 고려하지 않으며, 또한 서버의 상태 기준으로 판단하기 때문에 GET의 멱등성은 문제가 없는 것다.
```

### DELETE의 멱등 ⭕️

DELETE은 단순 삭제이기 때문에 멱등성을 가진다.

DELETE를 요청하면 해당 데이터는 삭제된다. 이후 DELETE를 여러번 요청하더라도 해당 리소스는 삭제된 상태 그대로일 것이니 서버의 상태는 변하지 않는다.

```
-- id값이 아닌 last 구조로 삭제 처리 (멱등적이지 않은 설계 ❌)
1. DELETE /post/last 요청
2. 서버에서 매번 마지막 게시글 삭제
```

```
-- last 구조로 삭제 처리: POST 사용 (멱등적인 설계 ⭕️)
1. POST /post/last 요청
```

### POST의 멱등 ❌

POST는 멱등성을 만족하지 않는다.

서버로 데이터를 전송하여 새로운 자원을 생성하는 역할을 하기 때문에 요청을 여러번 보내는 경우 매번 새로운 자원이 생겨나는 것이며, 이는 서버의 상태가 변경되는 것을 의미한다.

### PUT의 멱등 ⭕️

PUT은 대상 리소스를 덮어씌워 변경하거나, 대상 리소스가 없다면 새로 추가한다.

그래서 만약 대상 리소스가 없다면 POST와 똑같은 동작을 하게 되는데, POST는 매번 새로운 자원을 만들지만 PUT은 해당 자원이 이미 있다면 데이터만 덮어쓴다. 

따라서 요청을 한 번하든 여러번하든 결국 서버의 상태는 같아지기 때문에 멱등하다.

<aside>
💡 **멱등하다고 해서 항상 상태코드가 같은 것은 아니다.**
PUT 요청을 보냈을 때, 새로운 데이터를 생성한 경우 201 상태코드를, 기존 데이터를 갱신하면 200이나 204 코드를 응답한다. 다른 상태 코드를 응답한다고 해서 멱등하지 않은 것은 아니다.
서버의 상태는 동일하므로 멱등성을 가진다고 할 수 있다.  
(동일한 요청을 여러번 보내도 상태코드라는 결과값이 다를 수 있다)

</aside>

### PATCH의 멱등 ⭕️ or ❌

PUT이 리소스 전체 교체라면 PATCH는 리소스의 부분적인 수정 시 사용된다.

PATCH는 기본적으로 멱등성을 가지지 않는 메서드인데, 그 구현을 PUT과 동일한 방식으로 할 경우 멱등성을 가지게 되는 특성이 있다.

```
-- PATCH 메소드에 수정할 리소스의 일부분만 담아서 보내는 경우 (멱등적인 설계 ⭕️)
// 기존의 리소스
{
  id: 1,
  name: "김철수",
  age: 15  
}

// Send Request  
PATCH /users/1
{ 
  age:20
}

// 변경된 리소스
{
  id: 1,
  name: "김철수",
  age: 20
}

--> 한번 요청 보낸 후 같은 요청을 여러번 해도 같은 결과가 나온다.
```

```
-- PATCH 메소드에 동작을 증가하도록 변경하는 경우 (멱등적인 설계 ❌)
// 기존의 리소스
{
  id: 1,
  name: "김철수",
  age: 15  
}

// Send Request  
PATCH /users/1
{ 
  age: {
	  type: $inc,
	  value: 1
	  }
}

// 변경된 리소스
{
  id: 1,
  name: "김철수",
  age: 16
}

--> 요청 보낼 때마다 증가된 결과가 나오므로 멱등성을 가지지 않는다.
```

### 💡 멱등의 활용

`HTTP Method` 를 설계할 때, 굉장히 유용하게 활용될 수 있는 속성이다.

클라이언트가 서버에게 HTTP 메세지를 전송했는데, TIMEOUT과 같은 문제들로 인해 정상 응답을 못받은 상황이라고 가정해보자.

응답을 못받으면 다시 요청하면 그만이라고 생각할 수도 있지만, 여기서 HTTP의 멱등성의 유무가 들어간다.

세부적인 설계에 따라 다르겠지만 일반적으로 GET / PUT / DELETE와 같은 메서드들은 여러번 수행해도 그 결과에 변함이 없기 때문에, 장애 시 같은 요청을 다시 전송하도록 설계해도 문제는 없을 것이다.

하지만 POST나 멱등하지 않게 설계된 PATCH와 같은 메서드는 같은 요청을 다시 할 경우 문제 발생 가능성이 존재한다. 왜냐하면 네트워크나 인터넷 선이 문제였다면 서버에서는 정상 처리했는데 재요청 해버린다면 서버 입장에서는 한번 더 처리하게 되는 결과가 생긴다.

![Untitled](https://github.com/user-attachments/assets/3494b173-a4e7-4efd-a643-7ba5411b2f8e)


따라서 POST 요청같은 경우 더 큰 문제가 발생할 수 있기 때문에 요청을 또 보내는 것이 아닌, 다른 조취를 취하도록 설계해야 한다.

이런식으로 자동 복구 매커니즘의 사용 가능 여부에 “멱등성”이 설계의 기준이 된다.

---

### HTTP 캐시가능성

캐시 가능성은 “응답 결과 리소스를 캐싱해서 효율적으로 사용할 수 있는가”에 대한 여부이다.

HTTP 캐싱은 반복적인 요청을 줄이고 성능을 향상시키기 위해 사용된다. 일반적으로 GET 메서드가 캐싱에 많이 활용된다.

브라우저에도 캐시 공간이 있는데, 클라이언트가 서버에 한 번 요청했던 데이터에 대해 요청마다 다시 전송할 필요가 없도록 브라우저가 임시적으로 데이터를 보관하고 있는 장소이다. 

즉, **캐싱이 가능한 HTTP 메소드는 빠르게 결과값을 받을 수 있다.**

1. 처음 웹사이트 접속할 때 서버로부터 리소스를 모두 받아온다.
<img width="674" alt="Untitled" src="https://github.com/user-attachments/assets/90daa8b5-0803-4ba0-b478-d96be0a44c04">

2. 웹사이트를 재방문할 경우 캐시에서 리소스를 가져오기 때문에 빠르게 로드된다.
<img width="702" alt="Untitled" src="https://github.com/user-attachments/assets/ce79914b-be7f-4a8e-8e5b-f18b9bdbae0c">


- 스펙 상으로는 GET / POST / PATCH 메소드는 캐시가 가능하다.
- 하지만 실제로는 **GET**이나 **HEAD**정도만 캐시로 이용이 가능하고, POST, PATCH는 지원되지 않는 경우가 일반적이라고 한다. 왜냐하면 브라우저의 캐시를 이용하려면 원본 데이터가 변경되지 않고 유지되어야 하는데, POST / PUT / DELETE / PATCH 는 기본적으로 데이터가 변경되는 메서드이기 때문에, 만약 호출로 인해 데이터가 변경되게 되면 원본 데이터 또한 변경되어 캐시 데이터 불일치 문제가 생기기 때문이다.

> POST 캐싱
> 

*특정한 경우에만 사용되는 예외적인 방법이다. 특정 조건이 충족되면 캐싱이 가능하기도 하다.

- 멱등성이 보장된 POST 요청이어야 한다. → 일반적인 상황은 아니며, 대부분의 웹 표준에서 POST 요청은 캐싱되지 않는 것으로 처리한다.
- 캐싱 서버나 프록시가 POST 요청 캐싱을 지원해야 한다.
- 민감한 데이터는 캐시되지 않도록 해야 한다.
- HTTP의 헤더 중 `Cache-Control` 또는 `Expires`가 제대로 정의되어 있으면 캐싱 가능
    - Cache-Control:   캐시를 조작하기 위한 헤더
    - Expires: 자원에 대한 캐시 만료 시간을 나타내는 헤더
