## 비선형 자료구조 (그래프)

* 비선형 자료구조는 하나의 데이터 뒤에 N개의 데이터가 이어질 수 있는, 1:N 또는 N:N 구조로 데이터가 나열되는 자료구조를 뜻한다. 그래서 계층적 구조를 나타내기에 편한 장점이있다
* 선형 자료구조와 달리 데이터를 하나하나 탐색하지 않아도 원하는 데이터를 찾을 수 있다는 장점 때문에 비선형 자료구조를 활용한 다양한 알고리즘이 있다.
* 중요한 점은 `비선형 자료구조의 종류와 특징을 알고 문제 상황에 응용하는 능력`

* ### 그래프

* 그래프는 데이터를 포함하는 **정점(vertex)** 와 정점을 잇는 **간선(Edge)** 으로 구성된 자료구조다. 정점은 **노드(node)** 라고도 한다.

* 일반적으로 그래프는 각 용어의 영문 앞 글자를 따서 G = (V,E) 로 표현한다.

![image](https://github.com/gawgjiug/Eureka_CS_Study/assets/99489686/d29df7ff-a590-43d3-8b70-a8c9c4fadb28)


### 그래프 용어 정리

* 인접 정점 : 간선에 의해 연결된 정점을 말한다.
  
* 차수 : 무방향 그래프에서 하나의 정점에 인접한 정점의 수 (위 그림을 기준으로 정점 0의 차수는 3, 정점 3의 차수는 2)

* 진입 차수 : 방향 그래프에서 사용되는 용어로 외부 노드에서 들어오는 간선의 수를 말한다.

* 진출 차수 : 방향 그래프에서 사용되는 용어로 외부 노드에서 들어오는 간선의 수

* 경로 : 한 정점에서 다른 정점으로 이어지는 리스트를 뜻한다

* 경로 길이 : 경로를 구성하는 간선의 수를 말한다.

* 사이클 : 한 정점에서 시작해 같은 정점으로 돌아올 수 있는 경로를 말함.

### 그래프의 종류 

1. **무방향 그래프**

![](https://velog.velcdn.com/images/gawgjiug/post/c241ca34-19e1-415b-8a87-9370ed87554e/image.png)

* 무방향 그래프는 두 정점을 연결하는 간선에 방향이 없는 그래프이다.

* 정점의 개수가 n일때 최대 간선의 개수는 $n * (n-1)$ 이다.

2. **방향 그래프**

![](https://velog.velcdn.com/images/gawgjiug/post/59a4b2e8-5194-4176-ad98-82cb0cbfb0dd/image.png)


* 방향 그래프는 두 정점을 연결하는 간선에 방향이 존재하는 그래프이고 간선이 가리키는 방향으로만 이동할 수 있다.

* 방향 그래프도 마찬가지로 정점의 개수가 n일때 최대 간선의 개수는 $n * (n-1)$ 이다.

3. **가중치 그래프** 

![](https://velog.velcdn.com/images/gawgjiug/post/ff0f67f8-9d65-4a83-8b26-4cc7b91c7db1/image.png)

* 가중치 그래프는 두 정점을 이동할 때, 비용이 드는 그래프이다.

4. **완전 그래프**

![](https://velog.velcdn.com/images/gawgjiug/post/2fd0b708-9cf2-4fe6-b7c0-619df3e2ca8b/image.png)


* 완전 그래프는 모든 정점이 간선으로 연결된 그래프이다 (Cycle이 존재한다.)

### 그래프 구현 방법

* 그래프는 **인접 행렬** 또는 **인접 리스트** 로 구현할 수 있다.

**1. 인접 행렬**

* 인접 행렬이란 그래프의 정점을 2차원 배열로 만든 것을 말한다.

* 정점 간에 직접 연결되어 있다면 1, 아니라면 0을 저장한다

* 인접 행렬은 N의 제한이 적을 때 사용한다.

![](https://velog.velcdn.com/images/gawgjiug/post/bad58b36-e2c8-4dd9-aa39-9760721d705b/image.png)

#### 장점

1. 2차원 배열에 모든 정점의 간선 정보가 담겨 있기 때문에 두 정점에 대한 연결을 **조회**할 때, O(1)의 시간 복잡도를 가진다 (정점 1과 2와 연결되어있는지 확인하고 싶다? 1,2를 조회해보면 됨)

2. 인접 리스트에 비해 구현이 쉽다

#### 단점

1. 모든 정점에 대해 간선 정보를 입력해야 하므로 인접 행렬을 **생성** 할때는 O($n^2$)의 시간 복잡도가 소요된다.

2. 항상 2차원 배열이 필요하므로 필요 이상의 공간이 낭비된다.


**2. 인접 리스트**

* 인접 리스트는 그래프의 노드를 리스트로 표현한 것이다 주로 정점의 리스트 배열을 만들어서 관계를 설정한다.

![](https://velog.velcdn.com/images/gawgjiug/post/032080d2-1618-4252-b4ac-11e26636fd19/image.png)

#### 장점

1. 정점들의 연결 정보를 탐색할 때 O(n) 시간 복잡도가 소요된다 (N 은 간선의 갯수)

2. 필요한 만큼 공간을 사용하기 때문에 인접 행렬에 비해 상대적으로 공간의 낭비가 적다.

#### 단점 

1. 특정 두 정점이 연결되어 있는지 **조회**하기 위해서는 인접 행렬에 비해 시간이 오래걸린다 

2. 구현이 인접 행렬에 비해 어렵다.


### 인접 행렬 VS 인접 리스트

![](https://velog.velcdn.com/images/gawgjiug/post/67c1cfee-5a88-433b-b0af-9bf922c25780/image.png)


* 약 10억개의 노드가 있고 각 노드가 2개씩의 간선만 있는 상황이라고 할 때, 인접 행렬로 구현한 그래프에서는 한 정점의 차수를 구할 때 10억번의 연산을 수행할 것이다 반면, 인접 리스트로 구현한 그래프에서는 2번의 연산만 수행하면 된다.


### 경로 탐색(DFS VS BFS)

#### 너비 우선 탐색(BFS)

* **탐색을 시작하는 정점에서 가까운 정점을 먼저 탐색하는 방식**이다. 먼저 발견한 정점과 인접한 정점들을 탐색하면서 큐에 삽입한다. 이럴 경우 이전에 방문한 정점을 큐에 삽입 하면 끊임 없이 탐색을 반복할 수 있기 때문에,

* 탐색한 정점을 큐에 넣기 전에 이전에 방문했는지 반드시 확인해야 함.

```java
    public static void bfs(int start) {
        Queue<Integer> q = new LinkedList<>();
        q.offer(start);
        // 현재 노드를 방문 처리
        visited[start] = true;
        // 큐가 빌 때까지 반복
        while(!q.isEmpty()) {
            // 큐에서 하나의 원소를 뽑아 출력
            int x = q.poll();
            System.out.print(x + " ");
            // 해당 원소와 연결된, 아직 방문하지 않은 원소들을 큐에 삽입
            for(int i = 0; i < graph[x].size(); i++) {
                int y = graph[x].get(i);
                if(!visited[y]) {
                    q.offer(y);
                    visited[y] = true;
                }
            }
        }
    }
```
![image](https://github.com/gawgjiug/Eureka_CS_Study/assets/99489686/06e209af-e9f1-4d57-be69-6edd39649378)

### 깊이 우선 탐색(DFS)

* 깊이 우선 탐색은 **시작 정점에서 탐색 가능한 최대 깊이의 정점까지 탐색한다** 재귀 호출 또는 스택으로 구현할 수 있다.

```java
    public static void dfs(int x) {
        // 현재 노드를 방문 처리
        visited[x] = true;
        System.out.print(x + " ");
        // 현재 노드와 연결된 다른 노드를 재귀적으로 방문
        for (int i = 0; i < graph[x].size(); i++) {
            int y = graph[x].get(i);
            if (!visited[y]) dfs(y);
        }
    }
```



---

### 예상 질문

* 트리와 그래프의 차이점은 무엇인가?
* BFS와 DFS의 차이점은 무엇인가?
