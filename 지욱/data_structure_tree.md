### 트리

* **트리** 는 그래프의 한 종류로 사이클이 없어서 계층적 관계를 표현하는 데 유용하다. 

![](https://velog.velcdn.com/images/gawgjiug/post/5a68e164-a1f8-47ff-85d6-e85bc9c28032/image.png)


* 루트노드 : 부모 노드가 없는 노드로 트리에는 하나의 루트 노드가 존재한다.

* 부모 노드 : 루트 노드 방향으로 연결된 노드다. 

* 자식 노드 : 루트 노드의 반대 방향으로 연결된 노드다.

* 단말 노드 : 자식 노드가 없는 노드이다.

* 형제 노드 : 부모 노드가 같은 노드 (F,G)

* 레벨 : 루트 노드로 부터 노드의 상대적 위치를 의미함.

* 일반적으로 루트노드의 레벨은 0이다.

* 높이 : 트리의 최대 레베 +1을 의미함

* 차수 : 자식 노드의 개수


### 이진트리 

* 이진 트리는 자식 노드가 최대 2개인 트리이다. 대표적인 이진 트리의 종류는 다음과 같다.

#### 완전 이진트리

* 트리의 마지막 레벨을 제외한 모든 레벨에 노드가 채워져 있으며,  마지막 레벨은 왼쪽에서부터 오른쪽으로 노드가 채워져 있는 이진 트리다.

![](https://velog.velcdn.com/images/gawgjiug/post/1df6768a-305a-447a-a2dd-5cf55c48976e/image.png)


#### 포화 이진트리

* 트리의 마지막 레벨 까지 `노드가 모두 채워져 있는 이진트리` 이다. 따라서 포환 이진 트리는 곧 완전 이진 트리라고 할 수 있다.


![](https://velog.velcdn.com/images/gawgjiug/post/f028cb56-477b-4523-a954-737bb93a1a16/image.png)

#### 이진 탐색 트리 (BST Binary Search Tree)

* 한 노드의 `왼쪽 서브 트리는 해당 노드의 값보다 작은 값을 가진 노드로 구성되고, 오른쪽 서브 트리는 해당 노드의 값보다 큰 값을 가진 노드로 구성된 트리다.`

* 균형 잡힌 이진 탐색 트리에서는 루트 노드와 가까운 노드일 수록 검색해야 하는 노드 개수가 절반으로 줄어든다. 따라서 값을 검색하는 데 $O(logn)$ 이 소요된다. 

* 하지만 균형이 잡히지 않은 이진 트리에서는 검색하는데 시간 복잡도가 $O(n)$이 소요 되므로 이진 탐색 트리를 이용하는 장점이 사라진다.

* 그래서 완전 이진 트리로 이진 탐색 트리를 구성하려면 `균형 이진 탐색 트리)` 가 필요한 것이다. 

* 균형 이진 탐색 트리의 대표적인 예로는 레드-블랙 트리와 AVL 트리가 있다.


![](https://velog.velcdn.com/images/gawgjiug/post/38dc5c3c-340b-4cac-9cd5-308de5c17a74/image.png)

* 이진 탐색 트리에서 데이터의 추가, 삭제 연산 방식은 다음과 같다.


** 1. 데이터 추가 **

* 이진 탐색 트리에서 데이터 추가는 루트 노드 부터 차례대로 값을 비교해 나가면서 삽입할 자리는 찾는 방식이다.

* 추가하려는 데이터가 비교하는 노드보다 값이 큰 경우 오른쪽 자식 노드와 비교를 수행하고, 작은 경우는 왼쪽 자식 노드와 비교를 수행한다. 

** 2. 데이터 삭제 **

* 이진 탐색 트리에서 데이터를 삭제하는 경우는 자식 노드의 개수에 따라 3가지로 나눌 수 있다. 

* **자식 노드가 없는 경우** : 해당 노드만 삭제하면 된다. 

* **자식 노드가 1개인 경우** : 자식 노드를 삭제한 노드의 위치로 옮기면 된다. 

* **자식 노드가 2개인 경우** : 오른쪽 서브 트리에서 가장 작은 값을 삭제한 노드 위치로 옮기면 된다.

---

### 레드-블랙 트리

![](https://velog.velcdn.com/images/gawgjiug/post/e01fdeaa-7178-4acd-8fc8-628e8cf1f201/image.png)


* 레드 블랙 트리 또한 binary-search tree(이진탐색트리) 의 일종이다.

* 기존의 이진탐색트리 같은 경우 input이 이미 정렬되어 있다면(최악의 경우 한쪽으로 몰린경우), 높이가 n이 되어버리고, 따라서 시간복잡도 또한 O(n)에 도달하게 된다.

* 하지만 레드 블랙 트리의 경우 **특정 조건**을 지키면서 균형잡힌 이진트리가 되기 때문에 Search,Insert,Delete 연산을 최악의 경우에도 O(logN) 안에 가능하도록 해준다.

* 레드블랙 트리는 여러가지 속성을 통해 **특정 조건**을 지켜나가는데, 레드 블랙 트리의 속성을 아래와 같다.

1. 노드 색깔 속성 : 각 노드는 빨간색 또는 검은색으로 이루어져있다.

2. 루트 속성 : 루트 노드는 항상 검은색이다.

3. 리프 노드 속성: 모든 리프 노드(NIL)은 검은색이다 (레드블랙 트리에서는 일반적으로 리프노드를 'NIL' 로 간주하며, 이는 실제 데이터가 없는 더미 노드임.)

4. 레드 노드 속성: 빨간색 노드의 자식 노드는 항상 검은색이다. 즉, 빨간색 노드는 연속으로 나올 수 없다. (빨간색 노드의 부모 및 자식 노드는 모두 검은색).

5. 경로 속성: 모든 리프 노드에서 루트까지의 경로에는 같은 개수의 검은색 노드가 포함되어있음 이를 'black height'라고함.


### 레드 블랙 트리의 연산

* 레드 블랙 트리에서의 주요 연산들은 삽입, 삭제 , 검색이 있다. 검색은 일반적인 이진 탐색 트리와 동일하게 수행되지만, 삽입과 삭제는 트리의 균형을 유지하기 위해 추가적인 작업이 필요하다.

1. 삽입

* 삽입은 일반적인 이진 탐색 트리의 삽입 방식과 유사하지만, 삽입 후 트리의 균형을 맞추기 위해 추가적인 작업이 필요하다. 새로 삽입된 노드는 빨간색으로 표시되며, 다음과 같은 규칙을 통해 트리를 재구성 한다.

* 부모 노드가 검은색인 경우, 추가 작업을 필요없다.
* 부모 노드가 빨간색인 경우, 추가적인 재구성이 필요함. (재구성 방법에는 회전과 색 변경이 있다.)

2. 삭제

* 삭제는 일반적인 이진 탐색 트리의 삭제 방식과 유사하지만, 삭제 후 트리의 균형을 맞추기 위해 추가적인 작업이 필요하다. 노드를 삭제 한 후 트리의 속성을 위반하지 않도록 회전과 색깔 변경을 통해 트리를 재구성함.

**우선 삽입 후 재구성 경우의 수** 에 대해서 설명하겠다.


**용어 정의:**
* N: 새로 삽입된 노드
* P: N의 부모 노드
* G: N의 조부모 노드
* U: N의 삼촌 노드 (G의 다른 자식)

1. P가 빨간색이고, U가 빨간색인 경우 (부모 레벨의 노드가 전부 빨간색인 경우) 4번 속성 위반.(빨간색 노드는 연속으로 나올 수 없음)

* P와 U를 검은색으로 변경함. G를 빨간색으로 변경함. 이제 G를 다시 확인한다. 

* 만약 G가 루트 노드라면, G를 검은색으로 설정하여 균형을 맞춘다, G가 루트 노드가 아니라면, G의 부모가 빨간색인지 확인하고 위 과정을 반복함.

2. P가 빨간색이고, U가 검은색인 경우 (삼촌이 검은색인 경우) 

* 이 경우는 추가적인 회전과 색깔 변경이 필요함 이 경우는 N,P,G 의 상대적인 위치에 따라 다시 나눌 수 있다.

2-1. N이 P의 오른쪽 자식이고, P가 G의 왼쪽 자식인 경우 (Left_Right Case)

* P를 기준으로 우회전한다.. (노드의 오른쪽 자식을 부모로 올리고, 기준 노드는 오른쪽 자식의 왼쪽 자식이 되며, G는 오른쪽 자식(N)의 오른쪽 자식이 된다. )

* 이로 인해 N이 새로운 부모가 된다. 

2-2. N이 P의 왼쪽 자식이고, P가 G의 왼쪽 자식인 경우(Left-Left Case)

* 왼쪽으로 불균형을 이룰 경우에 가운데 노드를 중심으로 오른쪽으로 회전해서 균형을 맞춘다.

* P가 G의 위치로 올라가고 G는 P의 오른쪽 자식이되고, N은 P의 왼쪽 자식이 된다.

**RR(Right-Right Case)도 마찬가지이다. 가운데 노드를 중심으로 왼쪽으로 회전해서 균형을 맞춘다)

3. RL(Right-Left Case)

* P는 N의 오른쪽 자식이되고, P가 G의 위치로 올라가면서 동시에 G는 P의 왼쪽 자식이된다.


#### 결론

* 레드 블랙 트리는 삽입과 삭제 시 트리가 자동으로 균형을 유지한다는 장점을 가지고 있으며, 검색, 삽입, 삭제 모두 최악의 경우에도 O(nlogn)의 시간복잡도를 보장한다.

---

### AVL 트리 

* AVL 트리또한 이진 탐색트리의 한쪽으로 노드가 쏠리는 현상을 막기 위해 고안된 방식이다.

* 그래서 레드블랙트리와 일정 부분 비슷한데, 

* 우선 기본적으로 AVL 트리 또한 이진 탐색 트리의 속성을 가지며, 왼쪽,오른쪽 서브 트리의 높이 차이가 최대 1로 제한되어있다.

* 높이 차이가 1보다 커지면 회전을 통해 균형을 맞춰 높이 차이를 줄인다.

* 삽입, 검색, 삭제의 시간 복잡도가 O(logN)이다.

![](https://velog.velcdn.com/images/gawgjiug/post/4692168e-e2e5-4ba1-be01-fc99e9393e51/image.png)

AVL 트리는 모든 노드의 BF 가 -1,0,1 중 하나여야 한다. 만약 이를 벗어나면 균형이 깨졋다는 것을 의미하고, 이때 회전이 필요한 것

> $BF(K) = K의 왼쪽 서브트리의 높이 - K의 오른쪽 서브트리의 높이$

* 회전에 대해서는 앞서 설명했기 때문에 사진 설명만 추가하겠다.

#### 우회전

![](https://velog.velcdn.com/images/gawgjiug/post/eae9d2e0-831f-4e1b-9152-a44ca854cd68/image.png)

#### 좌회전

![](https://velog.velcdn.com/images/gawgjiug/post/0ac2650c-0eb2-454d-8339-6c02cab4832e/image.png)


#### LR Case

![](https://velog.velcdn.com/images/gawgjiug/post/851af6b8-81ca-4694-adfa-480d4f8107ef/image.png)

#### RL Case

![](https://velog.velcdn.com/images/gawgjiug/post/9bf69f77-ce1e-482e-831d-70653871fba2/image.png)

---

### 예상질문

``Q. 이진 탐색 트리에서 발생할 수 있는 문제는 무엇이고, 이를 보완할 수 있는 방법은?``

A: 이진 탐색트리에서는 트리가 한쪽으로 편향되어 있는 불균형이 발생할 수 있고 이러한 불균형은 시간 복잡도 면에서 효율적이지 못하다는 문제점이 있습니다.
이를 보완하기 위해 균형 이진 탐색 트리의 대표적인 예로는 레드-블랙 트리와 AVL 트리가 있습니다.


``Q. 트리와 그래프의 차이점은?``

A: 그래프는 정점과 간선으로 구성된 자료구조 이고, 사이클이 있을 수도, 없을 수도 있다. 또한 계층 관계가 존재하지 않지만, 트리의 경우 계층관계가 명확히 존재하고
사이클이 존재하지 않습니다
