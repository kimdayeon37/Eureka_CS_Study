# Deadlock (교착상태)

## Introduction

- 두 개 이상의 프로세스나 스레드가 서로 자원을 얻지 못해 다음 작업을 처리하지 못하는 (block) 상태
- 따라서 무한히 다음 자원을 기다리는 상태
- 시스템적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생한다

## 프로세스가 자원을 사용하는 절차

Request → Allocate → Use → Release

## Deadlock 발생 조건

아래 조건들을 <em>**모두**</em> 만족시켜야 Deadlock이 발생한다

- **상호 배제 (Mutual exclusion)**
  - 자원은 한 번에 한 프로세스만 사용할 수 있음
- **점유 대기 (Hold and wait)**
  - 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 존재해야 함
- **비선점 (No preemption)**
  - 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없음
- **순환 대기 (Circular wait)**
  - 자원을 기다리는 프로세스 간에 사이클이 형성되어야 함

## 데드락 처리

### Prevention (예방)

- 자원 할당 시 Deadlock의 4가지 필요조건 중 어느 하나가 만족되지 않도록 하는 것
- <mark>Utilization 저하, Throughput 감소, Starvation 문제 발생</mark>
- `Mutual Exclusion` 조건 제거
  - 여러 프로세스가 동시에 공유 자원에 접근할 수 있게 함
  - 공유해서는 안 되는 자원(e.g. CPU)의 경우 반드시 성립해야 함
- `Hold and Wait` 조건 제거 ⇒ 스스로 내려놓게 하기
  - 한 프로세스가 수행되기 전에 모든 자원을 할당시키고 나서 점유하지 않을 때에는 다른 프로세스가 자원을 요구하도록 하는 방법
  - 자원 과다 사용으로 인한 효율성, 프로세스가 요구하는 자원을 파악하는 데에 대한 비용, 자원에 대한 내용을 저장 및 복원하기 위한 비용, 기아 상태, 무한대기 등의 문제 존재
- `No Preemption` 조건 제거 ⇒ 강제로 빼앗기 (timer 등)
  - 프로세스가 어떤 자원을 기다려야 하는 경우 이미 보유한 자원이 선점됨
  - 모든 필요한 자원을 얻을 수 있을 때 프로세스 재시작
  - State를 쉽게 save하고 restore할 수 있는 자원에서 주로 사용 (CPU, Memory)
- `Circular Wait` 조건 제거
  - 모든 자원 유형에 할당 순서를 정하여 정해진 순서대로만 자원 할당

### Avoidance (회피)

- 자원 요청에 대한 부가적인 정보를 이용해 <em>Deadlock의 가능성이 없을 때에만 자원을 할당</em>
- <u>**2가지 Avoidance algorithm**</u>
  - <em>**Resource Allocation Graph algorithm**</em>
    - **Single** instance per resource types
    - 시스템 전체에서 오직 하나의 인스턴스만을 가질 수 있는 경우
      - 점선을 포함해서 Cycle이 생기면 자원을 주지 않음 (미래의 최악의 상황을 고려)
      - 점선: 프로세스가 자원을 미래에 요청할 수 있음 / 실선: 프로세스가 자원 요청 시
  - <em>**Banker's Algorithm**</em>
    - **Multiple** instance per resource types
    - 특정 자원 유형이 여러 인스턴스를 가질 수 있는 경우
      - 가정: 모든 프로세스는 자원의 최대 사용량을 미리 명시하고, 프로세스가 요청 자원을 모두 할당받은 경우 유한 시간 안에 이들 자원을 다시 반납한다
      - 자원 요청 시 Safe 상태를 유지할 경우에만 할당
        - 총 요청 자원의 수가 가용 자원의 수보다 적은 프로세스를 선택
        - 할당받은 프로세스가 종료되면 모든 자원을 반납

### Detection (탐지)

- <em>Deadlock 발생은 허용하되</em> 그에 대한 detection이 가능하고 발견 시 recover
- **Deadlock Detection**
  - 자원 요청 시, 탐지 알고리즘을 실행시켜 그에 대한 오버헤드 발생
  - <em>Single instance per resource types</em>
    - 자원할당그래프에서 사이클이 곧 Deadlock을 의미 (단, 여유자원이 있으면 무조건 할당해 줌)
    - 그래서 이때에는 프로세스 처리 후 자원을 내어놓는 것까지 고려하여 가용자원을 파악하고, 이를 바탕으로 현재 요청들을 다 처리할 수 있는 Sequence가 존재하면 Deadlock이 아니라고 판단
  - <em>Multiple instances per resource types</em>
    - Banker's Algorithm과 유사한 방법 활용
- **Wait-for graph Algorithm**
  - 자원할당그래프의 변형 - 프로세스만으로 노드 구성
  - Pj가 가지고 있는 자원을 Pk가 기다리는 경우 Pk → Pj 로 표시
  - Wait-for-graph 에 사이클이 존재하는지 주기적으로 조사 (O(n^2))

### Recovery (회복)

- 교착 상태를 일으킨 프로세스를 종료하거나, 할당된 자원을 해제시켜 회복시키는 방법
- Process termination
  - Deadlock에 연루된 모든 프로세스를 죽이는 방법
  - → Deadlock에 연루된 프로세스를 하나씩 죽여서 Deadlock이 사라지는지 확인
- Resource Preemption
  - 비용을 최소화할 Victim의 선정해서 자원 빼앗음
  - Safe state로 rollback하여 프로세스를 재시작
  - 동일한 프로세스가 계속해서 Victim으로 선정되는 경우 Starvation 문제 발생
    → Cost factor에 rollback 횟수도 같이 고려

### Ignorance (무시)

- Deadlock을 시스템이 책임지지 않는 방법으로 <u>대부분의 OS가 채택!</u>
- Deadlock이 일어나지 않는다고 생각하고 아무런 조치도 취하지 않음
  → 이거에 대한 처리 자체가 Overhead일 수도 있음. 사용자가 직접 프로세스 죽이는 등의 방법을 사용!

---

# Race Condition (경쟁 상태)

## Introduction

- 공유 자원에 대해 여러 프로세스가 동시에 접근할 때, 결과값에 영향을 줄 수 있는 상태
- 동시 접근 시 자료의 일관성을 해치는 결과 발생

## Race Condition 이 발생하는 경우

- **커널 작업 수행 중 인터럽트 발생**
  - `P` 커널모드에서 데이터를 로드하여 작업을 수행하다가 인터럽트가 발생하여 같은 데이터를 조작하는 경우
  - `S` 커널모드에서 작업을 수행하는 동안 인터럽트를 disable시켜 CPU 제어권을 가져가지 못하도록 한다
- **프로세스가 시스템콜 하여 커널모드로 진입 후 작업을 수행하는 도중 문맥교환이 발생할 때**
  - `P` 프로세스1이 커널모드에서 데이터를 조작하는 도중, 시간이 초과되어 CPU 제어권이 프로세스2로 넘어가 같은 데이터를 조작하는 경우 (프로세스1이 작업에 반영되지 않은 경우)
  - `S` 프로세스가 커널모드에서 작업하는 경우, 시간이 초과되어도 CPU 제어권이 다른 프로세스에게 넘어가지 않도록 함
- **멀티 프로세서 환경에서 공유 메모리 내의 커널 데이터에 접근할 때**
  - `P` 멀티 프로세서 환경에서 2개의 CPU가 동시에 커널 내부의 공유 데이터에 접근하여 조작하는 경우
  - `S` 커널 내부에 있는 각 공유 데이터에 접근할 때마다 그 데이터에 대한 lock/unlock을 하는 방법

---

![](https://velog.velcdn.com/images/corinthionia/post/0a1474ad-23c2-4db3-a173-ef1d79dd911b/image.png)

# Semaphore

## Introduction

- 공유된 자원에서 여러 프로세스가 동시에 접근하면 문제가 발생할 수 있다
  <u>→ 따라서 공유된 자원의 데이터는 한 번에 하나의 프로세스만 접근할 수 있도록 제한해야 한다</u>
- `세마포어(Semaphore)`
  - 멀티 프로그래밍 환경에서 공유 자원에 대한 접근을 제한하는 방법
- `임계구역(Critical Section)`
  - 여러 프로세스가 데이터를 공유하며 수행될 때, 각 프로세스에서 **공유 데이터를 접근하는 프로그램 코드 부분** (공통으로 접근하여 데이터를 수정할 수 있는 코드 영역)
  - 한 프로세스가 임계구역을 수행할 때에는 다른 프로세스가 접근하지 못하게 해야 한다

## 세마포어 P, V 연산

- `P` **임계구역 들어가기 전에 수행** (프로세스 진입 여부를 공유자원의 개수(S)를 통해 결정)
- `V` **임계구역 나올 때 수행** (자원 반납 알림, 대기 중인 프로세스를 깨우는 신호)
- 이를 통해 한 프로세스가 `P` 혹은 `V`를 수행하고 있는 동안 인터럽트 당하지 않게 된다

## 세마포어 구현

- `P`와 `V` 를 사용하여 임계구역에 대한 상호배제 구현이 가능하다

```text
P(S);
// -- 임계구역 --
V(S);
```

```c
procedure P(S)   --> 최초 S값은 1임
    while S=0 do wait  --> S가 0면 1이 될때까지 기다려야 함
    S := S-1   --> S를 0로 만들어 다른 프로세스가 들어 오지 못하도록 함
end P

--- 임계 구역 ---

procedure V(S) --> 현재상태는 S가 0임
    S := S+1   --> S를 1로 원위치시켜 해제하는 과정
end V
```

e.g. 최초 S 값은 1이고, 현재 해당 구역을 수행할 프로세스 A, B가 있다고 가정하자

1. 먼저 도착한 A가 P(S)를 실행하여 S를 0으로 만들고 임계구역에 들어간다
2. 그 뒤에 도착한 B가 P(S)를 실행하지만 S가 0이므로 대기상태에 들어간다
3. A가 임계구역 수행을 마치고 V(S)를 실행하면 S는 다시 1이 된다
4. B는 이제 P(S)에서 while문을 빠져나올 수 있고, 임계구역으로 들어가 수행한다

---

# Mutex (Mutual Exclustion)

## Introduction

- 임계구역을 가진 스레드들의 실행시간이 서로 겹치지 않고 단독으로 실행되게 하는 기술
- 해당 접근을 조율하기 위해 lock과 unlock을 사용한다 <em>(공유자원이 하나일 때 처리하는 동기화 방법)</em>
  - `lock` **임계구역에 들어갈 권한을 얻음** (만약 다른 프로세스/스레드가 임계구역 수행 중이라면 종료할 때까지 대기)
  - `unlock` **임계구역을 모두 사용했음을 알림** (대기 중인 다른 프로세스/스레드가 임계구역에 진입할 수 있음)
- 뮤텍스는 상태가 0, 1로 `이진 세마포어`라고 부르기도 함

## 뮤텍스 알고리즘

### 데커(Dekker) 알고리즘

- `flag`와 `turn` 변수를 통해 임계구역에 들어갈 프로세스/스레드를 결정하는 방식
  - `flag` 어떤 프로세스가 임계영역에 진입할 것인지 나타내는 변수
  - `turn` 어떤 프로세스가 임계구역에 들어갈 차례인지 나타내는 변수

```c
while(true) {
    flag[i] = true; // 프로세스 i가 임계 구역 진입 시도
    while(flag[j]) { // 프로세스 j가 현재 임계 구역에 있는지 확인
        if(turn == j) { // j가 임계 구역 사용 중이면
            flag[i] = false; // 프로세스 i 진입 취소
            while(turn == j); // turn이 j에서 변경될 때까지 대기
            flag[i] = true; // j turn이 끝나면 다시 진입 시도
        }
    }
}

// ------- 임계 구역 ---------

turn = j; // 임계 구역 사용 끝나면 turn을 넘김
flag[i] = false; // flag 값을 false로 바꿔 임계 구역 사용 완료를 알림
```

1. Pi가 임계구역 진입을 시도할 때, Pj가 임계구역에 있는지/들어가려고 하는지 확인
2. 만약 Pj가 임계구역에 있거나 임계구역에 들어갈 차례면, Pi의 진입을 취소하고 대기
3. Pj가 임계구역을 빠져나가면 Pi를 진입
4. 이후 작업을 처리하고 나올 때 Pj에게 turn을 넘김

### 피터슨(Peterson) 알고리즘

- 데커 알고리즘과 비슷하지만 상대방 프로세스/스레드에게 진입 기회를 양보한다는 것에 차이가 있음

```c
while(true) {
    flag[i] = true; // 프로세스 i가 임계 구역 진입 시도
    turn = j; // 다른 프로세스에게 진입 기회 양보
    while(flag[j] && turn == j) { // 다른 프로세스가 진입 시도하면 대기
    }
}

// ------- 임계 구역 ---------

flag[i] = false; // flag 값을 false로 바꿔 임계 구역 사용 완료를 알림
```

1. Pi가 임계영역에 진입하려 할 때, `flag[i] = true`로 변경하여 임계영역 진입 의사를 밝힘
2. Pi가 아닌 다른 프로세스가 임계구역에 들어가려 했는지 확인하기 위해 `turn = j`로 변경
3. 만약 Pj가 임계구역에 들어가려고 했다면, Pj에게 공유자원을 할당하고 자원을 다 사용하면 Pi 차례가 되어 임계구역에 진입
4. Pi의 작업이 완료되면 `flag[i] = false`로 설정하여 `Pi`가 임계구역에서의 작업이 끝났다는 것을 알림

### 제과점(Bakery) 알고리즘

- 여러 프로세스/스레드에 대한 처리가 가능한 알고리즘
- **가장 작은 수의 번호표**를 가지고 있는 프로세스가 임계구역에 진입

```c
while(true) {

    isReady[i] = true; // 번호표 받을 준비
    number[i] = max(number[0~n-1]) + 1; // 현재 실행 중인 프로세스 중에 가장 큰 번호 배정
    isReady[i] = false; // 번호표 수령 완료

    for(j = 0; j < n; j++) { // 모든 프로세스 번호표 비교
        while(isReady[j]); // 비교 프로세스가 번호표 받을 때까지 대기
        while(number[j] && number[j] < number[i] && j < i);

        // 프로세스 j가 번호표 가지고 있어야 함
        // 프로세스 j의 번호표 < 프로세스 i의 번호표
    }
}

// ------- 임계 구역 ---------

number[i] = 0; // 임계 구역 사용 종료
```

1. `isReady[i]`에서 대기번호(number) 부여받는 중임을 다른 프로세스에게 알리고 번호표를 할당받음
2. 번호표 수령을 완료했다면 `isReady[i] = false`로 설정 후, 번호표를 부여받는 다른 스레드가 없는지 체크하고 있다면 대기함
3. 자신보다 작은 번호표를 가진 스레드가 있는지 확인
   a. 베이커리 알고리즘에서는 번호표가 중복되지 않을 것이라는 보장은 없음
   b. 이 경우 낮은 이름을 가지고 있는 스레드를 먼저 처리한다
4. 다른 프로세스의 number 값이 자신보다 크거나 같을 경우 대기
5. 임계구역에 진입해 작업을 완료하고, 해당 프로세스를 0으로 처리
